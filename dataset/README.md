This file explains the structure of the output files generated by Arbiter

# The .log file


This file contains all the logs generated by Arbiter in the format "(date)s - (name)s - (LEVEL) - (msg)"


The static data-dependency analysis of Arbiter considers constants as negatives and terminates the analysis when a constant value is encountered.


The symbolic execution phase of Arbiter can generate two types of states depending on whether a source function is explicitly provided.


1. Entry state : This situation is used when the data-dependency starts from the function entry point. (ie no source function provided)
2. Checkpoint state : This situation is used when the data-dependency starts from a provided source function.


# Recon.json

This file contains output from the recon step of Arbiter.
It contains one dictionary with different key-value pairs that will be explained below.

```
{
  "cfg_creation": 1,           
  "cfg_blocks": 2932,          
  "cfg_edges": 5723,
  "recovered_functions": 658,  
  "identified_functions": 3    
} 

```

The `cfg_creation` value denotes the amount of time (in seconds) spent on recovering the CFG of the binary.
The `cfg_blocks`, `cfg_edges` and `recovered_functions` represent the number of blocks, edges and functions recovered from the binary.
The `identified_functions` denotes the number of functions that have been identified to contain the sink of interest.


# DDA.json


This file contains the output from the static data-dependency analysis of Arbiter.
It contains one dictionary with multiple nested dictionaries.

```
{
  "identified_functions": 3,   
  "4205545": {                 
    "sink_count": 1,
    "cfg_creation": 5,         
    "ddg_creation": 7,         
    "cdg_creation": 0,         
    "sources": 27,             
    "constants": 1             
  },
  ...
}
```

In the outermost dictionary, the `identified_functions` denotes the number of functions that were passed as input to this step of Arbiter.
This value is equal to the `identified_functions` value from the Recon.json file.


Each nested dictionary in this file corresponds to a function identified in the recon step.
The address of the function is used as the key to this nested dictionary.

In the nested dictionaries, the `sink_count` represents the number of sinks identified in the function.
The values `cfg_creation`, `ddg_creation` and `cdg_creation` represent the time spent (in seconds) in creating the CFG, DDG and CDG respectively.
The `sources` key represents the number of calls to source-functions identified in this function.
The `constants` value represents the number of data-dependencies that resulted in constant values.

If `sink_count - constants` is greater than 0, this function will be marked for the next step of Arbiter's analysis.


# UCSE.json


This file contains the output from the under-constrained symbolic execution analysis of Arbiter.
It contains one dictionary with multiple nested dictionaries similar to the previous DDA.json file.

```
{
  "identified_functions": 2,   
  "4242068": {                 
    "entry_state": 1,
    "paths_found": 1,          
    "paths_timedout": 0,       
    "exploration_time": 0,     
    "expressions_tracked": 1,  
    "filtered_expressions": 1, 
    "sat_states": 1
  },    
  "4242537": {
    "checkpoint_state": 1,     
    "paths_found": 1,          
    "paths_timedout": 0,
    "expressions_tracked": 1,
    "filtered_expressions": 1,
    "sat_states": 1,
    "exploration_time": 0
  } 
  ...
}

```

In the outermost dictionary, the `identified_functions` denotes the number of functions that were passed as input to this step of Arbiter.


Each nested dictionary in this file corresponds to a function identified in the static data-dependency analysis step.
The address of the function is used as the key to this nested dictionary.

In the nested dictionaries, the `paths_found` and `paths_timedout` represent the number of paths that successfully reached the target sink and those that timed out before reaching the sink respectively.


The nested dictionary contains either the `entry_state` or `checkpoint_state` key depending upon whether a source-function was identified in the current function.
The value of this key represents the number of initial symbolic states generated.

The `expressions_tracked` denotes the number of symbolic expressions tracked during the UCSE step.
Since the initial symbolic expression might be used to generate multiple expressions, Arbiter filters out the tracked expressions that do not influence the final value passed to the sink.
The `filtered_expressions` denote the number of expressions that remain after this filtering step.

The `exploration_time` represents the time (in seconds) that was spent during UCSE.

And finally the `sat_states` represents the number of satisfied states.
If the value `sat_states` is greater than 0, it means that Arbiter has found a bug in this function.
